#!/usr/bin/env python3

import socket
import sys
import threading
import queue
from select import select
from termcolor import colored
# Termcolor colors blue, magenta, grey
# Used: red, green, yellow, white, magenta, cyan

DEBUG = False
COLOR = True
REQ_COLOR = "white"
RESP_COLOR = "cyan"
print_q = queue.Queue()


class RequestParser:
    def __init__(self, method, url, version, headers, req_lines=()):
        self.method = method
        self.url = url
        self.version = version
        self.headers = headers
        self.req_lines = req_lines

    @classmethod
    def from_bytes(cls, data):
        head, *lines = data.splitlines()
        method, url, version = head.split(b' ')
        headers = {}
        for i, line in enumerate(lines):
            if not line:
                break
            key, _, value = line.partition(b': ')
            headers[key] = value
        req_lines = lines[i:]
        return cls(method, url, version, headers, req_lines)

    def __getitem__(self, key):
        return self.headers[key]

    def __bytes__(self):
        first = b' '.join((self.method, self.url, self.version))
        headers = [k + b': ' + v for k, v in self.headers.items()]
        return b'\r\n'.join([first] + headers + self.req_lines + [b''])

    def __str__(self):
        return bytes(self).decode("utf-8", "ignore")


class ProxyAbort(Exception):
    pass


class ProxyRetry(Exception):
    pass


class ProxyConnection:
    def __init__(self, client_sock, client_addr):
        self.client_sock = client_sock
        self.client_addr = client_addr
        self.server_sock = None
        self.request_blocks = []
        self.response_blocks = []
        self.request = None
        self.server_addr = None
        self.response = None

    def __hash__(self):
        return hash(self.client_addr)

    def __eq__(self, other):
        return self.client_addr == other.client_addr

    def parse_request(self):
        req = b''.join(self.request_blocks)
        if not req:
            raise ProxyRetry("Request was empty")
        request = RequestParser.from_bytes(req)
        if request.method == b'CONNECT':  # We dont support ssl yet
            raise ProxyAbort("HTTPS not yet supported")
        request.url = request.url.replace(b'http://' + request[b'Host'], b'')
        request.url += b'' if request.url else b'/'
        host, _, port = request[b'Host'].partition(b':')
        port = 80 if port == b'' else int(port)
        self.server_addr = (host, port)
        self.request = bytes(request)

    def term_str(self):
        req = colored(self.request.decode("utf-8", "ignore"), REQ_COLOR)
        resp = colored(self.response.decode("utf-8", "ignore"), RESP_COLOR)
        return f"{req}\n{resp}"

    def fileno(self):
        if self.server_sock is None:
            return self.client_sock.fileno()
        return self.server_sock.fileno()

    def recv(self, size=1024):
        if self.server_sock is None:
            return self.request_blocks.append(self.client_sock.recv(size))
        return self.response_blocks.append(self.server_sock.recv(size))

    def advance(self):
        if self.server_sock is None and self.request_blocks:
            self.forward_req()
            return False
        elif self.response_blocks:
            self.close()
            return True
        return False

    def forward_req(self):
        self.parse_request()
        self.server_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
            self.server_sock.connect(self.server_addr)
        except socket.gaierror:
            raise ProxyAbort(f"Could not connect to {self.server_addr}")

        self.server_sock.sendall(self.request)

    def close(self):
        if not self.response_blocks:
            raise ProxyRetry("Hadn't yet recieved server response")
        self.response = b''.join(self.response_blocks)
        self.client_sock.sendall(self.response)
        self.client_sock.close()
        self.server_sock.close()

    def abort(self):
        self.client_sock.close()
        if self.server_sock is not None:
            self.server_sock.close()


def cprint(*args, color=None, file=sys.stderr, flush=None, **kwargs):
    c = (lambda s: colored(s, color)) if (COLOR and color) else (lambda s: s)
    print(*map(c, args), file=file, flush=flush, **kwargs)


def csubmit(*args, **kwargs):
    print_q.put((args, kwargs))


def print_thread():
    while True:
        args, kwargs = print_q.get()
        kwargs.setdefault("flush", print_q.empty())
        cprint(*args, **kwargs)


def log_level(label, color=None):
    return lambda *a, **kw: csubmit(label, *a, color=color, **kw)


info = log_level("[INFO]", "green")
warning = log_level("[WARNING]", "yellow")
error = log_level("[ERROR]", "red")
debug = log_level("[DEBUG]", "magenta")


def handle_connections(job_q):
    all_conns = set()
    try:
        while True:
            # get all current values on the queue. they need their requests
            while not job_q.empty() or not all_conns:
                client, addr = job_q.get()
                info(f"Accepted connection from {addr}")
                conn = ProxyConnection(client, addr)
                all_conns.add(conn)

            needs_recv = set(select(all_conns, [], [], 0.1)[0])
            for conn in needs_recv:
                conn.recv()

            needs_advance = all_conns - needs_recv
            for conn in needs_advance:
                try:
                    if conn.advance():
                        all_conns.remove(conn)
                        csubmit(conn.term_str())
                except ProxyAbort as e:
                    error(f"Aborting connection from {conn.client_addr}: {e}")
                    all_conns.remove(conn)
                    conn.abort()
                except ProxyRetry as e:
                    warning(
                        f"Retrying connection from {conn.client_addr}: {e}")
    finally:
        for connection in all_conns:
            connection.abort()


def accept_connections(sock, queue):
    while True:
        queue.put(sock.accept())


def main(argv):
    port = 8080
    q = queue.Queue()
    threading.Thread(target=handle_connections, args=(q,), daemon=True).start()
    threading.Thread(target=print_thread, daemon=True).start()
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.bind(("localhost", port))
        s.listen()
        try:
            info(f"Accepting connections on port {port}")
            accept_connections(s, q)
        except KeyboardInterrupt:
            warning("Recieved keyboard interrupt. Shutting down")


if __name__ == "__main__":
    sys.exit(main(sys.argv))
