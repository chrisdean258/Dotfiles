#!/usr/bin/env python3

import select
import socket
import sys
import threading
import queue
from termcolor import colored
# Termcolor colors blue, magenta, grey
# Used: red, green, yellow, white, magenta, cyan

DEBUG = False
COLOR = True
REQ_COLOR = "white"
RESP_COLOR = "cyan"


class ProxyConnection:
    def __init__(self, client_sock, client_addr):
        self.client_sock = client_sock
        self.client_addr = client_addr
        self.server_sock = None
        self.request_blocks = []
        self.response_blocks = []
        self.request = None
        self.server_addr = None
        self.response = None

    def __hash__(self):
        return hash(self.client_addr)

    def __eq__(self, other):
        return self.client_addr == other.client_addr

    def parse_request(self):
        req = b''.join(self.request_blocks)
        if req.startswith(b'CONNECT'):  # We dont support ssl yet
            raise ValueError("HTTPS not yet supported")
        if not req:
            return False
        host, _, port = req.splitlines()[1].partition(b' ')[2].partition(b':')
        port = 80 if port == b'' else int(port)
        self.server_addr = (host, port)
        self.request = req.replace(b'http://' + host + b'/', b'/')
        self.request = self.request.replace(b'http://' + host, b'/')
        return True

    def term_str(self):
        req = colored(self.request.decode("utf-8", "ignore"), REQ_COLOR)
        resp = colored(self.response.decode("utf-8", "ignore"), RESP_COLOR)
        return f"{req}\n{resp}"

    def fileno(self):
        if self.server_sock is None:
            return self.client_sock.fileno()
        return self.server_sock.fileno()

    def recv(self, size=1024):
        if self.server_sock is not None:
            self.response_blocks.append(self.server_sock.recv(size))
        else:
            self.request_blocks.append(self.client_sock.recv(size))

    def advance(self):
        if self.server_sock is None:
            self.forward_req()
            return False
        else:
            self.close()
            return True

    def forward_req(self):
        info(f"Recieved request from {self.client_addr}")
        if not self.parse_request():
            return
        self.server_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
            self.server_sock.connect(self.server_addr)
        except socket.gaierror:
            raise ValueError(f"Could not connect to {self.server_addr}")

        self.server_sock.sendall(self.request)

    def close(self):
        self.response = b''.join(self.response_blocks)
        self.client_sock.sendall(self.response)
        self.client_sock.close()
        self.server_sock.close()

    def abort(self):
        self.client_sock.close()
        if self.server_sock is not None:
            self.server_sock.close()


def cprint(*args, color=None, file=sys.stderr, flush=True, **kwargs):
    def c(s): return colored(s, color) if COLOR else s
    print(*map(c, args), file=file, flush=flush, **kwargs)


def debug(*args, **kwargs):
    if not DEBUG:
        return
    cprint("[Debug]", *args, color="magenta", **kwargs)


def info(*args, **kwargs):
    cprint("[INFO]", *args, color="green", **kwargs)


def warning(*args, **kwargs):
    cprint("[WARNING]", *args, color="yellow", **kwargs)


def error(*args, **kwargs):
    cprint("[ERROR]", *args, color="red", **kwargs)


def readable(socks, timeout=0.1):
    return select.select(socks, [], [], timeout)[0]


def handle_connections(queue):
    all_conns = set()
    try:
        while True:
            # get all current values on the queue. they need their requests
            while not queue.empty() or not all_conns:
                client, addr = queue.get()
                info(f"Accepted connection from {addr}")
                conn = ProxyConnection(client, addr)
                all_conns.add(conn)

            needs_recv = set(readable(all_conns))
            for conn in needs_recv:
                conn.recv()

            needs_advance = all_conns - needs_recv
            for conn in needs_advance:
                try:
                    if conn.advance():
                        all_conns.remove(conn)
                        print(conn.term_str())
                except ValueError as e:
                    error(f"Aborting connection from {conn.client_addr}: {e}")
                    all_conns.remove(conn)
                    conn.abort()
    finally:
        for connection in all_conns:
            connection.abort()


def accept_connections(sock, queue):
    while True:
        queue.put(sock.accept())


def main(argv):
    port = 8080
    q = queue.Queue()
    threading.Thread(target=handle_connections, args=(q,), daemon=True).start()
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.bind(("localhost", port))
        s.listen()
        try:
            info(f"Accepting connections on port {port}")
            accept_connections(s, q)
        except KeyboardInterrupt:
            warning("Recieved keyboard interrupt. Shutting down")


if __name__ == "__main__":
    sys.exit(main(sys.argv))
