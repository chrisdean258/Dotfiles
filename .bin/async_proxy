#!/usr/bin/env python3

import asyncio
import curses
import sys
from select import select
from itertools import takewhile
import concurrent.futures
import traceback

import io

CompletedConnection = 1
LogMessage = 2
StdinRead = 3


class RequestParser:
    def __init__(self, method, url, version, headers, req_lines=()):
        self.method = method
        self.url = url
        self.version = version
        self.headers = headers
        self.req_lines = req_lines

    @classmethod
    def from_bytes(cls, data):
        head, *lines = data.splitlines()
        method, url, rest = head.split(b' ', 2)
        headers = {}
        for i, line in enumerate(takewhile(lambda a: a, lines)):
            key, _, value = line.partition(b': ')
            headers[key] = value
        req_lines = lines[i+1:]
        return cls(method, url, rest, headers, req_lines)

    def __bytes__(self):
        first = b' '.join((self.method, self.url, self.version))
        headers = [k + b': ' + v for k, v in self.headers.items()]
        return b'\r\n'.join([first] + headers + self.req_lines + [b''])

    def fix_url(self):
        self.url = b'/' + b''.join(self.url.split(b'/', 3)[3:])

    def host_port(self):
        url, _, port = self.headers[b'Host'].partition(b':')
        port = int(port) if port else 80
        return url, port


async def gather_http_req(reader):
    to = []
    while not to or b'\r\n\r\n' not in to[-1]:
        to.append(await reader.read(1024))

    req = RequestParser.from_bytes(b''.join(to))
    if b'Content-Length' in req.headers:
        length = int(req.headers[b'Content-Length'])
        to.append(await reader.read(length))

    return b''.join(to)


async def log(queue, *args, **kwargs):
    await queue.put((LogMessage, (args, kwargs)))


async def log_con(queue, c_addr, s_addr, c_rec, s_rec):
    await queue.put((CompletedConnection, (c_addr, s_addr, c_rec, s_rec)))


async def handle_client(client_r, client_w, record):
    try:
        addr = client_w.get_extra_info('peername')
        await log(record, "accept connection from", addr)
        request = RequestParser.from_bytes(await gather_http_req(client_r))
        request.fix_url()
        req = bytes(request)
        server_addr = request.host_port()
        server_r, server_w = await asyncio.open_connection(*server_addr)
        server_w.write(req)
        resp = await gather_http_req(server_r)
        client_w.write(resp)
        await log_con(record, addr, server_addr, req, resp)
    finally:
        client_w.close()
        server_w.close()


async def record_events(event_q, stdin_queue):
    while True:
        etype, event = await event_q.get()
        if etype == CompletedConnection:
            print(f"Connection from {event[0]} to {event[1]}")
            print(event[2].decode('utf-8', 'ignore'))
            print(event[3].decode('utf-8', 'ignore'), flush=True)
        elif etype == LogMessage:
            print(*event[0], **event[1])
        elif etype == StdinRead:
            assert 0, "Unreachable"
        event_q.task_done()


def curses_setup():
    stdscr = curses.initscr()
    curses.noecho()
    curses.cbreak()
    stdscr.keypad(True)
    curses.curs_set(False)
    curses.start_color()
    curses.use_default_colors()
    curses.init_pair(1, curses.COLOR_WHITE, -1)
    curses.init_pair(2, curses.COLOR_CYAN, -1)
    return stdscr


def curses_teardown(stdscr):
    curses.nocbreak()
    stdscr.keypad(False)
    curses.curs_set(True)
    curses.echo()
    curses.endwin()


async def notify_stdin(event_q, ready_queue):
    running = True

    def _run():
        nonlocal running
        while running and sys.stdin not in select([sys.stdin], [], [], 0.1)[0]:
            pass

    loop = asyncio.get_event_loop()
    executor = concurrent.futures.ThreadPoolExecutor(max_workers=5)

    try:
        while True:
            await loop.run_in_executor(executor, _run)
            await event_q.put((StdinRead, None))
            await ready_queue.get()
            ready_queue.task_done()
    except asyncio.CancelledError:
        running = False


def draw_conns(lwin, nwin, cons, selected, offset):
    my_con = None
    try:
        for i, con in enumerate(cons):
            (caddr, cport, *_), (saddr, sport), req, resp = con
            string = saddr.decode("utf-8") + ":" + str(sport)
            if i == selected:
                my_con = con
                lwin.addstr(i + 1, 1, string, curses.A_BOLD)
            else:
                lwin.addstr(i + 1, 1, string)
    except curses.error:
        pass
    try:
        if my_con is not None:
            nwin.clear()
            lineno = 1 - offset
            nwin.attron(curses.color_pair(1))
            for line in req.splitlines():
                if lineno > 0:
                    nwin.addstr(lineno, 1, line)
                lineno += 1
            nwin.attroff(curses.color_pair(1))
            nwin.attron(curses.color_pair(2))
            for line in resp.splitlines():
                if lineno > 0:
                    nwin.addstr(lineno, 1, line)
                lineno += 1
            nwin.attroff(curses.color_pair(2))
    except curses.error:
        pass


def draw_nots(win, nots):
    win.clear()
    for i, n in enumerate(nots):
        try:
            win.addstr(i + 1, 1, n)
        except curses.error:
            pass


async def curses_main(stdscr, event_q, stdin_q):
    try:
        COLS = 0
        ROWS = 0
        nots = []
        cons = []
        nheight = 10

        selection = 0
        offset = 0

        def box():
            stdscr.box()
            cur_con.box()
            conn_win.box()
            not_win.box()

        def refresh():
            stdscr.refresh()
            cur_con.refresh()
            conn_win.refresh()
            not_win.refresh()

        def draw_cons():
            draw_conns(conn_win, cur_con, cons, selection, offset)

        def draw_notifs():
            draw_nots(not_win, nots)

        while True:
            curses.update_lines_cols()
            if ROWS != curses.LINES or COLS != curses.COLS:
                ROWS = curses.LINES
                COLS = curses.COLS
                lwidth = min(COLS // 7, 20)
                nheight = min(ROWS // 10, 10)
                conn_win = curses.newwin(ROWS - 2, lwidth, 1, 1)
                not_win = curses.newwin(
                    nheight, COLS - lwidth - 2, ROWS - nheight - 1, lwidth + 1)
                cur_con = curses.newwin(
                    ROWS - nheight - 2, COLS - lwidth - 2, 1, lwidth + 1)

            box()
            refresh()
            etype, event = await event_q.get()
            if etype == CompletedConnection:
                cons.append(event)
                draw_cons()
            elif etype == LogMessage:
                buf = io.StringIO()
                print(*event[0], **event[1], file=buf)
                nots.append(buf.getvalue())
                nots = nots[-nheight + 2:]
                draw_notifs()
            elif etype == StdinRead:
                key = stdscr.getch()
                if key == ord('q'):
                    break
                elif key == ord('j'):
                    selection = min(selection + 1, len(cons) - 1)
                    offset = 0
                    draw_cons()
                elif key == ord('k'):
                    selection = max(selection - 1, 0)
                    offset = 0
                    draw_cons()
                elif key == curses.KEY_UP or key == ord('h'):
                    offset = max(0, offset - 1)
                    draw_cons()
                elif key == curses.KEY_DOWN or key == ord('l'):
                    offset += 1
                    draw_cons()
                else:
                    nots.append(repr(key))
                    nots = nots[-nheight + 2:]
                    draw_notifs()
                await stdin_q.put(())

            event_q.task_done()
    except Exception as e:
        print(str(e), traceback.format_exc(), file=open("msg", "w"))
        raise


async def first_done(*events):
    done, pending = await asyncio.wait(
        map(asyncio.create_task, events), return_when=asyncio.FIRST_COMPLETED)
    for task in pending:
        task.cancel()
    return done


async def curses_record(event_q):
    try:
        stdin_q = asyncio.Queue()
        stdscr = curses_setup()
        not_stdin = notify_stdin(event_q, stdin_q)
        curses_task = curses_main(stdscr, event_q, stdin_q)
        await first_done(not_stdin, curses_task)
    finally:
        curses_teardown(stdscr)
        await stdin_q.join()


async def main(argv):
    asyncio.get_running_loop()
    record = asyncio.Queue()
    server = await asyncio.start_server(
        lambda a, b: handle_client(a, b, record), 'localhost', 8080)
    try:
        await first_done(
            server.serve_forever(),
            # record_events(record),
            curses_record(record),
        )

    except KeyboardInterrupt:
        await record.join()


if __name__ == "__main__":
    sys.exit(asyncio.run(main(sys.argv)))
