#!/usr/bin/env python3

import asyncio
import concurrent.futures
import curses
import enum
import io
import sys
import traceback
from contextlib import suppress, contextmanager
from select import select
from itertools import takewhile

_real_print = print
f = open("msg", "w")


def print(*args, **kwargs):
    _real_print(*args, file=f, flush=True, **kwargs)


async def asyncio_complete_one(*events):
    done, pending = await asyncio.wait(
        map(asyncio.create_task, events), return_when=asyncio.FIRST_COMPLETED)
    print(done)
    for task in pending:
        task.cancel()
    return done


async def poll(condition):
    while not condition():
        await asyncio.sleep(0.1)


async def file_readable(of):
    await poll(lambda: of in select([of], [], [], 0)[0])


class RequestParser:
    def __init__(self, method, url, version, headers, req_lines=()):
        self.method = method
        self.url = url
        self.version = version
        self.headers = headers
        self.req_lines = req_lines

    @classmethod
    def from_bytes(cls, data):
        head, *lines = data.splitlines()
        method, url, rest = head.split(b' ', 2)
        headers = {}
        for i, line in enumerate(takewhile(lambda a: a, lines)):
            key, _, value = line.partition(b': ')
            headers[key] = value
        req_lines = lines[i+1:]
        return cls(method, url, rest, headers, req_lines)

    def __bytes__(self):
        first = b' '.join((self.method, self.url, self.version))
        headers = [k + b': ' + v for k, v in self.headers.items()]
        return b'\r\n'.join([first] + headers + self.req_lines + [b''])

    def fix_url(self):
        self.url = b'/' + b''.join(self.url.split(b'/', 3)[3:])

    def host_port(self):
        url, _, port = self.headers[b'Host'].partition(b':')
        port = int(port) if port else 80
        return url, port


class MesgType(enum.Enum):
    CompletedConnection = enum.auto()
    CompletedTLSConnection = enum.auto()
    LogMessage = enum.auto()
    StdinRead = enum.auto()


class AsyncHTTPServer:
    def __init__(self, queue):
        self.queue = queue
        self.server = None

    @ staticmethod
    async def gather_http_req(reader):
        to = []
        while not to or b'\r\n\r\n' not in to[-1]:
            to.append(await reader.read(1024))

        req = RequestParser.from_bytes(b''.join(to))
        if b'Content-Length' in req.headers:
            length = int(req.headers[b'Content-Length'])
            to.append(await reader.read(length))

        return b''.join(to)

    async def run(self, host='localhost', port=8080):
        self.server = await asyncio.start_server(self.handle_client, host, port)
        await self.server.serve_forever(),

    async def log(self, *args, **kwargs):
        await self.queue.put((LogMessage, (args, kwargs)))

    async def log_con(self, c_addr, s_addr, c_rec, s_rec):
        await self.queue.put((CompletedConnection, (c_addr, s_addr, c_rec, s_rec)))

    async def handle_tls_client(self, c_r, c_w, c_addr, s_addr, con_mess):
        await log_con(self.queue, c_addr, s_addr, con_mess, b'[ABORTED]')

    async def handle_client(self, client_r, client_w):
        server_w = None
        try:
            addr = client_w.get_extra_info('peername')
            await self.log("accept connection from", addr)
            request = RequestParser.from_bytes(await gather_http_req(client_r))
            request.fix_url()
            req = bytes(request)
            server_addr = request.host_port()
            # TLS
            if request.method == b'CONNECT':
                await handle_tls_client(
                    client_r, client_w, addr, server_addr, req, self.queue)
                return
            server_r, server_w = await asyncio.open_connection(*server_addr)
            server_w.write(req)
            resp = await gather_http_req(server_r)
            client_w.write(resp)
            await self.log_con(addr, server_addr, req, resp)
        finally:
            client_w.close()
            if server_w is not None:
                server_w.close()


class Logger:
    def __init__(self, queue):
        self.queue = queue
        self.running = False

    async def run(self):
        self.running = True
        while self.running:
            etype, event = await self.queue.get()
            await {
                MesgType.CompletedConnection: self.CompletedConnection,
                MesgType.CompletedTLSConnection: self.CompletedTLSConnection,
                MesgType.LogMessage: self.LogMessage,
                MesgType.StdinRead: self.StdinRead,
            }[etype](event)
            self.queue.task_done()

    def stop(self):
        self.running = False

    async def CompletedConnection(self, event):
        raise NotImplemented

    async def CompletedTLSConnection(self, event):
        raise NotImplemented

    async def LogMessage(self, event):
        raise NotImplemented

    async def StdinRead(self, event):
        raise NotImplemented


class StdoutLogger(Logger):
    async def CompletedConnection(self, event):
        caddr, saddr, req, resp = event
        print(f"Connection from {caddr} to {saddr}")
        print(req.decode('utf-8', 'ignore'))
        print(resp.decode('utf-8', 'ignore'), flush=True)

    async def LogMessage(self, event):
        print(*event[0], **event[1])


class CursesLogger(Logger):
    def __init__(self, queue):
        super().__init__(queue)
        self.stdin_q = None
        self.selection = 0
        self.offset = 0
        self.selwin = None
        self.connwin = None
        self.notwin = None
        self.conns = []
        self.nots = []
        self.COLS = 0
        self.ROWS = 0

    def setup(self):
        self.stdscr = curses.initscr()
        curses.noecho()
        curses.cbreak()
        self.stdscr.keypad(True)
        curses.curs_set(False)
        curses.start_color()
        curses.use_default_colors()
        curses.init_pair(1, curses.COLOR_WHITE, -1)
        curses.init_pair(2, curses.COLOR_CYAN, -1)

    def teardown(self):
        curses.nocbreak()
        self.stdscr.keypad(False)
        curses.curs_set(True)
        curses.echo()
        curses.endwin()

    def setup_windows(self):
        self.lwidth = min(self.COLS // 7, 20)
        self.nheight = min(self.ROWS // 10, 10)
        self.connwin = curses.newwin(self.ROWS - 2, self.lwidth, 1, 1)
        self.notwin = curses.newwin(
            self.nheight,
            self.COLS - self.lwidth - 2,
            self.ROWS - self.nheight - 1,
            self.lwidth + 1)
        self.selwin = curses.newwin(
            self.ROWS - self.nheight - 2,
            self.COLS - self.lwidth - 2,
            1,
            self.lwidth + 1)
        self.stdscr.box()
        self.stdscr.refresh()
        self.draw_conns()
        self.draw_nots()

    async def detect_size_change(self):
        def _size_changed():
            curses.update_lines_cols()
            return (self.COLS, self.ROWS) != (curses.COLS, curses.LINES)
        while self.running:
            await poll(_size_changed)
            self.COLS, self.ROWS = curses.COLS, curses.LINES
            self.setup_windows()

    async def notify_stdin(self):
        while self.running:
            await file_readable(sys.stdin)
            event = self.stdscr.getch()
            await self.queue.put((MesgType.StdinRead, event))

    @staticmethod
    def addstr(win, line, col, string, *args, **kwargs):
        with suppress(curses.error):
            if line > 0 and col > 0:
                win.addstr(line, col, string, *args, **kwargs)

    @staticmethod
    def addstrs(win, start_line, col, strs, *args, **kwargs):
        for i, string in enumerate(strs):
            CursesLogger.addstr(win, i + start_line, col,
                                string, *args, **kwargs)

    @contextmanager
    def attr(win, attr):
        winattron(attr)
        yield
        win.attroff(attr)

    def draw_conns(self):
        my_con = None
        for i, con in enumerate(self.conns):
            (caddr, cport, *_), (saddr, sport), req, resp = con
            string = saddr.decode("utf-8") + ":" + str(sport)
            if i == self.selected:
                my_con = con
                self.addstr(self.selwin, i + 1, 1, string, curses.A_BOLD)
            else:
                self.addstr(self.selwin, i + 1, 1, string)
        self.selwin.box()
        self.selwin.refresh()
        if my_con is not None:
            (caddr, cport, *_), (saddr, sport), req, resp = my_con
            self.connwin.clear()
            self.connwin.box()
            offset = self.offset
            lines = req.splitlines()[offset:]
            with CursesLogger.attr(self.connwin, curses.color_pair(1)):
                self.addstrs(self.connwin, 1, 1, lines[offset:])
            start = len(lines) + 1
            offset = max(offset - len(lines), 0)
            lines = resp.splitlines()[offset:]
            with CursesLogger.attr(self.connwin, curses.color_pair(2)):
                self.addstrs(self.connwin, start, 1, lines)
        self.connwin.box()
        self.connwin.refresh()

    def draw_nots(self):
        self.nots = self.nots[-self.nheight + 2:]
        self.notwin.clear()
        self.notwin.box()
        self.addstrs(self.notwin, 1, 1, self.nots)
        self.notwin.refresh()

    async def StdinRead(self, event):
        if event == ord('q'):
            self.stop()
        elif event == ord('j'):
            self.selection = min(self.selection + 1, len(self.conns) - 1)
            self.offset = 0
            self.draw_conns()
        elif event == ord('k'):
            self.selection = max(self.selection - 1, 0)
            self.offset = 0
            self.draw_conns()
        elif event == curses.KEY_UP or event == ord('h'):
            self.offset = max(0, self.offset - 1)
            self.draw_conns()
        elif event == curses.KEY_DOWN or event == ord('l'):
            self.offset += 1
            self.draw_conns()
        else:
            self.nots.append(repr(event))
            self.draw_nots()

    async def LogMessage(self, event):
        buf = io.StringIO()
        print(*event[0], **event[1], file=buf)
        self.nots.append(buf.getvalue())
        nots = nots[-self.nheight + 2:]
        self.draw_nots()

    async def CompletedConnection(self, event):
        self.conns.append(event)
        self.draw_conns()

    async def run(self):
        self.setup()
        try:
            not_stdin = self.notify_stdin()
            size_change = self.detect_size_change()
            curses_task = super().run()
            await asyncio_complete_one(curses_task, size_change, not_stdin)
        finally:
            self.teardown()


async def main(argv):
    record = asyncio.Queue()
    server = AsyncHTTPServer(record)
    logger = CursesLogger(record)
    try:
        await asyncio_complete_one(server.run(), logger.run())
    except KeyboardInterrupt:
        await record.join()


if __name__ == "__main__":
    sys.exit(asyncio.run(main(sys.argv)))
