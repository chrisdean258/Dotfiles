let g:imawimp = 1
let g:hllonglines = 1
let g:manage_sessions = 1
let g:auto_update = 0
let g:old_c_comments = 1
let g:md_format_para = 1
let g:use_syntastic = 0
let g:ale_fix_on_save = 1
let g:ale_lint_on_save = 1
let g:ale_lint_on_text_changed = 'never'
let g:ale_lint_on_insert_leave = 0
let g:ale_lint_on_enter = 0
let g:ale_rust_cargo_check_tests = 1
let g:ale_rust_cargo_check_examples = 1
let g:ale_fixers = {"rust": "rustfmt", "python": ["autopep8"], }
let g:ale_linters = {"python": ["flake8", "autoimport", "isort", "black"], "rust":["cargo"], "copper": ["copper"]}
nmap <silent> <C-k> <Plug>(ale_previous_wrap)
nmap <silent> <C-j> <Plug>(ale_next_wrap)


command! DndFixup :call DndFixup()
function! DndFixup()
	g/^\s*[-+]/normal! kJ
	%s/\([+-]\)\s*/\1/ge
endfunction

nnoremap <F10> :echo "hi<" . synIDattr(synID(line("."),col("."),1),"name") . '> trans<' . synIDattr(synID(line("."),col("."),0),"name") . "> lo<" . synIDattr(synIDtrans(synID(line("."),col("."),1)),"name") . ">"<CR>
au ColorScheme elflord hi! link ALEError Error
au ColorScheme elflord hi! link MarkDownError Normal

autocmd FileType c :setlocal commentstring=/*\ %s\ */

if $TERM =~ "^st"
  au ColorScheme elflord highlight Folded ctermfg=Black guifg=Black
  au ColorScheme elflord highlight Folded ctermfg=Black guifg=Black
  au ColorScheme elflord highlight Folded ctermfg=Black guifg=Black
  au ColorScheme elflord highlight Folded ctermfg=Black guifg=Black
endif
au ColorScheme elflord highlight tablinesel ctermfg=DarkGrey guifg=DarkGrey
au ColorScheme elflord highlight tabline ctermfg=black guifg=black
au VimResized * wincmd =
call HighLightSettings()

map H ^
map L $

nmap <leader>y "*y
vmap <leader>y "*y

function! RunSH()
	let line = getline('.')->trim(" \t$", 1)
	let idt = repeat(" ", indent('.'))
	call append(line('.'), map(systemlist(line), {_, v -> idt . v}))
endfunction


command! Run :call RunSH()

function! MDTemplate()
	let title = expand("%:t:r")->tolower()
	if title == "readme" || title == "notes"
		title = expand("%:p:h:t")
	endif
	call append(0, "# " .. title->tr('-_', '  ')->substitute('\<.', '\u&', "g"))
endfunction

function! FindLoc(loc_list, curpos)
	let ll =  a:loc_list->mapnew({i, v-> [i, v]})
	let [_, lnum, col, _, _] = a:curpos

	for [i, v] in ll
		if v.lnum == lnum
			return [i - 1, (i + 1) % len(ll)]
		elseif v.lnum > lnum
			return [i - 1, i]
		endif
	endfor
	return [-1, 0]
endfunction

"[{'lnum': 3, 'bufnr': 5, 'col': 1, 'pattern': '', 'valid': 1, 'vcol': 0, 'nr': -1, 'type': 'E', 'module': '', 'text': 'F821: undefined name ''skldjf'''}]
function! LocListNextWrap(offset)
	let loc_list = getloclist(0)
	if len(loc_list) == 0
		return
	endif
	let curpos = getcurpos()
	let [p, n] = FindLoc(loc_list, curpos)
	let selected = loc_list[a:offset < 0 ? p : n]
	if selected.lnum == line('.')
		call setpos('.', [0, selected.lnum + a:offset, selected.col, "^"])
		call LocListNextWrap(a:offset)
	else
		call setpos('.', [0, selected.lnum, selected.col, "^"])
	endif
endfunction

command! Lnext :call LocListNextWrap(1)
command! Lprev :call LocListNextWrap(-1)
cabbrev lnext <C-R>=CommandLineStart("lnext", "Lnext")<CR>
cabbrev ln <C-R>=CommandLineStart("lnext", "Lnext")<CR>
cabbrev lprev <C-R>=CommandLineStart("lprev", "Lprev")<CR>
cabbrev lp <C-R>=CommandLineStart("lprev", "Lprev")<CR>

nnoremap <localleader>e :call LocListNextWrap(1)<CR>
nnoremap <localleader>E :call LocListNextWrap(-1)<CR>


au BufNewFile *.md :call MDTemplate()
nnoremap j <nop>
nnoremap k <nop>
nnoremap hh <nop>
nnoremap ll <nop>
