#!/usr/bin/env python3
from xonsh.prompt.__amalgam__ import git_dirty_working_directory as gdwd
from xonsh.prompt.__amalgam__ import current_branch as gcb
from shlex import split
from itertools import *
import random
import os
import sys
import re

$XONSH_SHOW_TRACEBACK = False
$CASE_SENSITIVE_COMPLETIONS = False
$ENABLE_VI_MODE = True

if 'SSH_TTY' in ${...}:
    $HOME = $PWD
    $PROMPT = '{RED}{rv:[{}] }{NO_COLOR}{env_name}{BOLD_GREEN}{user}@{hostname}{NO_COLOR}:{BOLD_BLUE}{cwd}{GREEN}{curr_branch: ({})}{NO_COLOR}{prompt_end} '
else:
    $PROMPT = '{RED}{rv:[{}] }{NO_COLOR}{env_name}{BOLD_GREEN}{user}{NO_COLOR}:{BOLD_BLUE}{cwd}{GREEN}{curr_branch: ({})}{NO_COLOR}{prompt_end} '

$PROMPT_FIELDS["rv"] = lambda: __xonsh__.history and __xonsh__.history.rtns[-1] or None
$PROMPT_FIELDS['curr_branch'] = lambda: gcb() and (gcb() + "*" * (gdwd() or 0))


@events.on_transform_command
def bash_preproc(cmd, **kw):
    inputs = [a["inp"] for a in __xonsh__.history.all_items()][::-1]
    prev = lambda pre: next((i for i in inputs if i.startswith(pre)), "")
    transformations = {
        r"!!": lambda m: prev(""),
        r"!\$": lambda m: split(prev(""))[-1],
        r"!\^": lambda m: split(prev(""))[0],
        r"!\*": lambda m: " ".join(prev("")[1:]),
        r"!([\w]+)": lambda m: prev(m.group(1)),
        r"\$\?": lambda m: str(_.rtn),
        r"\$(\d)": lambda m: "$ARG" + m.group(1),
        r"\$\$": str(os.getpid()),
        r"\$\@": "$ARGS",
        r"(\d+)d(\d+)": lambda m: str(sum(random.choices(range(1, int(m.group(2)) + 1), k=int(m.group(2))))),
    }
    for expr, action in transformations.items():
        cmd = re.sub(expr, action, cmd)
    return cmd

jmp_cache = g`~/.cache/jmp/jmp`[0]
jump = False
expr = r".*"
@events.on_chdir
def record(olddir, newdir, **kw):
    global jump
    if olddir == newdir or jump:
        jump = False
        return
    ls
    with open(jmp_cache, "a") as f:
        print(newdir, file=f)

def _j(args):
    global jump
    global expr
    def cleanup():
        with open(jmp_cache, "r") as f:
            dirs = [l for l in f.readlines() if os.path.isdir(l.strip())]
        dirs = reversed(list(set(reversed(dirs))))
        with open(jmp_cache, "w") as f:
            print("".join(dirs), file=f)
    if args:
        expr = re.compile(r".*\/.*".join(args) + r"[^/]*$", flags=re.IGNORECASE)
    dirs = {l.strip() for l in !(tac @(jmp_cache)) if re.search(expr, l)}
    if $PWD in dirs and re.search(expr, $PWD):
        dirs = dropwhile(lambda a: a != $PWD, cycle(dirs))
        next(dirs, None)
    newdir = next(iter(dirs), None)
    if newdir and os.path.isdir(newdir):
        jump = True
        cd @(newdir)
    else:
        cleanup()


def _alias(arg):
    ret = 0
    if not arg:
        for alias, cmd in aliases.items():
            print("{}={}".format(alias, cmd))
    for a in arg:
        name, eq, alias = split(a)[0].partition("=")
        if eq == "=":
            aliases[name] = alias
        elif arg in aliases:
            print("{}={}".format(arg, aliases[arg]))
        else:
             print("alias: {}: not found".format(a))
             ret = 1
    return ret

def _ff(args):
    if args:
        file @(" ".join(args))
    else:
        file *


aliases["alias"] = _alias
aliases["j"] = _j
aliases["ff"] = _ff

alias la="ls -la"
alias c="clear"
alias es="exec xonsh"
alias ..="cd .."
alias "-=cd -"
